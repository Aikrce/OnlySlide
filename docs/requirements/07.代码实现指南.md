# OnlySlide 代码实现指南

## 1. 整体架构实现

### 1.1 模块化结构

OnlySlide使用模块化MVVM架构，将系统分为两个主要Swift Package：

```
OnlySlide/
├── Packages/
│   ├── OnlySlideCore/    # 核心业务逻辑
│   └── OnlySlideUI/      # 用户界面（MVVM架构）
└── OnlySlide/            # 主应用
```

#### Package依赖配置

```swift
// OnlySlideCore/Package.swift
let package = Package(
    name: "OnlySlideCore",
    platforms: [.iOS(.v18), .macOS(.v15)],
    products: [
        .library(name: "OnlySlideCore", targets: ["OnlySlideCore"]),
    ],
    dependencies: [],
    targets: [
        .target(name: "OnlySlideCore"),
        .testTarget(name: "OnlySlideCoreTests", dependencies: ["OnlySlideCore"]),
    ]
)

// OnlySlideUI/Package.swift
let package = Package(
    name: "OnlySlideUI",
    platforms: [.iOS(.v18), .macOS(.v15)],
    products: [
        .library(name: "OnlySlideUI", targets: ["OnlySlideUI"]),
    ],
    dependencies: [
        .package(path: "../OnlySlideCore")
    ],
    targets: [
        .target(
            name: "OnlySlideUI",
            dependencies: ["OnlySlideCore"]
        ),
        .testTarget(name: "OnlySlideUITests", dependencies: ["OnlySlideUI"]),
    ]
)
```

### 1.2 应用入口点

```swift
// OnlySlide/OnlySlideApp.swift
import SwiftUI
import OnlySlideCore
import OnlySlideUI

@main
struct OnlySlideApp: App {
    // 使用AppStateManager管理全局状态
    @StateObject private var appState = AppStateManager.shared
    
    // 使用CoreDataManager管理数据持久化
    private let coreDataManager = CoreDataManager.shared
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(\.managedObjectContext, coreDataManager.viewContext)
                .environmentObject(appState)
        }
        #if os(macOS)
        .commands {
            // macOS菜单栏命令
            SidebarCommands()
            TextEditingCommands()
            
            // 自定义文件菜单
            CommandMenu("File") {
                Button("Export as PDF") {
                    // Export logic
                }
                .keyboardShortcut("e", modifiers: [.command, .shift])
            }
        }
        #endif
    }
}
```

## 2. 核心模块实现 (OnlySlideCore)

### 2.1 协议定义实现

按照契约式编程原则，先定义关键协议：

```swift
// OnlySlideCore/Sources/Protocols/FileManagement/FileImporting.swift
import Foundation
import UniformTypeIdentifiers

/// 负责导入外部文件到应用中
public protocol FileImporting {
    /// 导入幻灯片模板文件
    /// - Parameter url: 文件URL
    /// - Returns: 导入的文档对象
    /// - Throws: 导入错误
    func importTemplateFile(from url: URL) async throws -> ImportedDocument
    
    /// 导入内容文件（文本、Word等）
    /// - Parameter url: 文件URL
    /// - Returns: 导入的内容对象
    /// - Throws: 导入错误
    func importContentFile(from url: URL) async throws -> ImportedContent
    
    /// 获取支持的模板文件类型
    func supportedTemplateTypes() -> [UTType]
    
    /// 获取支持的内容文件类型
    func supportedContentTypes() -> [UTType]
}

// OnlySlideCore/Sources/Protocols/TemplateAnalysis/SlideTemplateAnalyzing.swift
import Foundation

/// 负责分析幻灯片模板并提取结构和样式信息
public protocol SlideTemplateAnalyzing {
    /// 分析幻灯片模板文档
    /// - Parameter document: 导入的文档
    /// - Returns: 模板分析结果，包含结构和样式信息
    /// - Throws: 分析过程中的错误
    func analyzeTemplate(document: ImportedDocument) async throws -> TemplateAnalysisResult
    
    /// 获取分析进度
    /// - Returns: 当前分析进度(0.0-1.0)
    func currentProgress() -> Double
    
    /// 取消正在进行的分析
    func cancelAnalysis()
}

// OnlySlideCore/Sources/Protocols/SlideGeneration/SlideGenerating.swift
import Foundation

/// 负责根据内容和样式生成幻灯片
public protocol SlideGenerating {
    /// 生成幻灯片演示文稿
    /// - Parameters:
    ///   - content: 结构化内容
    ///   - styleModel: 样式模型
    /// - Returns: 生成的演示文稿
    /// - Throws: 生成过程中的错误
    func generateSlides(content: StructuredContent, 
                        styleModel: StyleModel) async throws -> GeneratedPresentation
    
    /// 获取生成进度
    /// - Returns: 当前生成进度(0.0-1.0)
    func generationProgress() -> Double
    
    /// 取消正在进行的生成
    func cancelGeneration()
}
```

### 2.2 数据模型实现

```swift
// OnlySlideCore/Sources/Models/Document/ImportedDocument.swift
import Foundation

public struct ImportedDocument: Identifiable, Equatable {
    public let id: UUID
    public let name: String
    public let url: URL
    public let fileType: DocumentType
    public let data: Data
    public let createdAt: Date
    
    public init(id: UUID = UUID(), name: String, url: URL, fileType: DocumentType, data: Data, createdAt: Date = Date()) {
        self.id = id
        self.name = name
        self.url = url
        self.fileType = fileType
        self.data = data
        self.createdAt = createdAt
    }
}

public enum DocumentType: String, Codable {
    case pptx
    case ppt
    case key
    case pdf
    case unknown
}

// OnlySlideCore/Sources/Models/Style/StyleModel.swift
import Foundation
import SwiftUI

public struct StyleModel: Identifiable, Codable {
    public let id: UUID
    public let name: String
    public let sourceDocumentId: UUID?
    public let colorScheme: ColorScheme
    public let typography: Typography
    public let layouts: [SlideLayout]
    
    public init(id: UUID = UUID(), name: String, sourceDocumentId: UUID? = nil, colorScheme: ColorScheme, typography: Typography, layouts: [SlideLayout]) {
        self.id = id
        self.name = name
        self.sourceDocumentId = sourceDocumentId
        self.colorScheme = colorScheme
        self.typography = typography
        self.layouts = layouts
    }
}

public struct ColorScheme: Codable {
    public let primary: ColorValue
    public let secondary: ColorValue
    public let accent: ColorValue
    public let background: ColorValue
    public let text: ColorValue
    public let additional: [ColorValue]
    
    // 初始化方法...
}

public struct ColorValue: Codable, Hashable {
    public let red: Double
    public let green: Double
    public let blue: Double
    public let alpha: Double
    public let name: String?
    
    public var color: Color {
        Color(red: red, green: green, blue: blue, opacity: alpha)
    }
    
    // 初始化方法...
}

public struct Typography: Codable {
    public let titleFont: FontDescription
    public let headingFont: FontDescription
    public let bodyFont: FontDescription
    public let accentFont: FontDescription?
    
    // 初始化方法...
}

public struct FontDescription: Codable {
    public let familyName: String
    public let weight: FontWeight
    public let size: Double
    public let isItalic: Bool
    
    // 初始化方法...
}

public enum FontWeight: String, Codable {
    case ultraLight
    case thin
    case light
    case regular
    case medium
    case semibold
    case bold
    case heavy
    case black
}
```

### 2.3 服务实现示例

```swift
// OnlySlideCore/Sources/Services/FileService/FileImportService.swift
import Foundation
import UniformTypeIdentifiers

public class FileImportService: FileImporting {
    private let fileManager = FileManager.default
    
    public init() {}
    
    public func importTemplateFile(from url: URL) async throws -> ImportedDocument {
        // 检查文件类型是否支持
        guard let fileType = documentType(from: url), 
              supportedTemplateTypes().contains(where: { $0.conforms(to: url.utType ?? .data) }) else {
            throw FileImportError.unsupportedFileType
        }
        
        // 使用文件协调器安全读取文件
        return try await withCheckedThrowingContinuation { continuation in
            let coordinator = NSFileCoordinator(filePresenter: nil)
            
            coordinator.coordinate(readingItemAt: url, options: .withoutChanges, error: nil) { accessURL in
                do {
                    let data = try Data(contentsOf: accessURL)
                    let document = ImportedDocument(
                        name: accessURL.deletingPathExtension().lastPathComponent,
                        url: accessURL,
                        fileType: fileType,
                        data: data
                    )
                    continuation.resume(returning: document)
                } catch {
                    continuation.resume(throwing: FileImportError.readError(error))
                }
            }
        }
    }
    
    public func importContentFile(from url: URL) async throws -> ImportedContent {
        // 类似的实现...
        // 这里需要根据不同内容类型(txt, docx等)进行不同处理
        fatalError("Not implemented")
    }
    
    public func supportedTemplateTypes() -> [UTType] {
        [.presentation, .powerpoint, UTType(filenameExtension: "pptx") ?? .data]
    }
    
    public func supportedContentTypes() -> [UTType] {
        [.plainText, .rtf, UTType(filenameExtension: "docx") ?? .data]
    }
    
    // 辅助方法确定文档类型
    private func documentType(from url: URL) -> DocumentType? {
        switch url.pathExtension.lowercased() {
        case "pptx": return .pptx
        case "ppt": return .ppt
        case "key": return .key
        case "pdf": return .pdf
        default: return .unknown
        }
    }
}

public enum FileImportError: Error {
    case unsupportedFileType
    case readError(Error)
    case invalidContent
}
```

### 2.4 CoreData实现

```swift
// OnlySlideCore/Sources/CoreData/CoreDataManager.swift
import CoreData
import Foundation

public class CoreDataManager {
    public static let shared = CoreDataManager()
    
    private let containerName = "OnlySlideDataModel"
    
    public lazy var persistentContainer: NSPersistentCloudKitContainer = {
        let container = NSPersistentCloudKitContainer(name: containerName)
        
        // 为每种存储配置选项
        guard let description = container.persistentStoreDescriptions.first else {
            fatalError("Failed to retrieve persistent store description")
        }
        
        // 启用历史记录跟踪以支持同步
        description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
        
        // 初始化持久化存储
        container.loadPersistentStores { _, error in
            if let error = error as NSError? {
                fatalError("Failed to load persistent stores: \(error), \(error.userInfo)")
            }
        }
        
        // 合并策略设置
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        container.viewContext.automaticallyMergesChangesFromParent = true
        
        // 启用撤销管理器
        container.viewContext.undoManager = UndoManager()
        
        return container
    }()
    
    // 访问主视图上下文
    public var viewContext: NSManagedObjectContext {
        persistentContainer.viewContext
    }
    
    // 创建后台上下文用于长时间运行的任务
    public func newBackgroundContext() -> NSManagedObjectContext {
        let context = persistentContainer.newBackgroundContext()
        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        return context
    }
    
    // 执行保存操作
    public func saveContext() {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                let nsError = error as NSError
                print("Failed to save context: \(nsError), \(nsError.userInfo)")
            }
        }
    }
    
    // 在后台执行任务
    public func performBackgroundTask(_ block: @escaping (NSManagedObjectContext) -> Void) {
        persistentContainer.performBackgroundTask(block)
    }
    
    // 在后台执行任务并等待完成
    public func performBackgroundTaskAndWait(_ block: @escaping (NSManagedObjectContext) -> Void) {
        persistentContainer.performBackgroundTask(block)
    }
    
    private init() {}
}
```

### 2.5 仓库模式实现

```swift
// OnlySlideCore/Sources/CoreData/Repositories/Repository.swift
import Foundation

/// 通用仓库协议，定义CRUD操作
public protocol Repository<Entity> {
    associatedtype Entity
    
    /// 创建新实体
    func create(_ entity: Entity) async throws -> Entity
    
    /// 获取所有实体
    func fetchAll() async throws -> [Entity]
    
    /// 按ID获取实体
    func fetch(id: UUID) async throws -> Entity?
    
    /// 更新实体
    func update(_ entity: Entity) async throws -> Entity
    
    /// 删除实体
    func delete(_ entity: Entity) async throws
    
    /// 删除全部实体
    func deleteAll() async throws
}

// OnlySlideCore/Sources/CoreData/Repositories/ProjectRepository.swift
import CoreData
import Foundation

/// 项目仓库具体实现
public actor ProjectRepository: Repository {
    public typealias Entity = Project
    
    private let context: NSManagedObjectContext
    
    public init(context: NSManagedObjectContext) {
        self.context = context
    }
    
    public func create(_ project: Project) async throws -> Project {
        return try await withCheckedThrowingContinuation { continuation in
            context.perform {
                let entity = ProjectEntity(context: self.context)
                entity.id = project.id
                entity.name = project.name
                entity.createdAt = project.createdAt
                entity.updatedAt = project.updatedAt
                
                do {
                    try self.context.save()
                    continuation.resume(returning: project)
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    
    public func fetchAll() async throws -> [Project] {
        return try await withCheckedThrowingContinuation { continuation in
            context.perform {
                let fetchRequest: NSFetchRequest<ProjectEntity> = ProjectEntity.fetchRequest()
                
                do {
                    let results = try self.context.fetch(fetchRequest)
                    let projects = results.map { entity in
                        Project(
                            id: entity.id ?? UUID(),
                            name: entity.name ?? "",
                            createdAt: entity.createdAt ?? Date(),
                            updatedAt: entity.updatedAt ?? Date()
                        )
                    }
                    continuation.resume(returning: projects)
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    
    // 其他Repository方法实现...
}
```

## 3. UI模块实现 (OnlySlideUI)

### 3.1 MVVM组织结构

```swift
// OnlySlideUI/Sources/ViewModels/Base/BaseViewModel.swift
import Combine
import SwiftUI

public class BaseViewModel: ObservableObject {
    // 通用状态
    @Published public var isLoading = false
    @Published public var errorMessage: String?
    @Published public var hasError = false
    
    // 取消令牌集合
    public var cancellables = Set<AnyCancellable>()
    
    public init() {}
    
    // 通用任务执行框架
    public func performTask<T>(_ task: @escaping () async throws -> T) async -> T? {
        await MainActor.run {
            self.isLoading = true
            self.errorMessage = nil
            self.hasError = false
        }
        
        do {
            let result = try await task()
            
            await MainActor.run {
                self.isLoading = false
            }
            
            return result
        } catch {
            await MainActor.run {
                self.isLoading = false
                self.errorMessage = error.localizedDescription
                self.hasError = true
            }
            return nil
        }
    }
}

// OnlySlideUI/Sources/ViewModels/Analysis/TemplateAnalysisViewModel.swift
import Combine
import Foundation
import OnlySlideCore
import SwiftUI

class TemplateAnalysisViewModel: BaseViewModel {
    // 注入的服务
    private let analyzer: SlideTemplateAnalyzing
    private let fileImporter: FileImporting
    
    // 发布的状态
    @Published var importedDocument: ImportedDocument?
    @Published var analysisResult: TemplateAnalysisResult?
    @Published var analysisProgress: Double = 0
    @Published var selectedTemplate: Template?
    @Published var extractedStyles: [StyleElement] = []
    
    // 进度更新计时器
    private var progressTimer: Timer?
    
    init(analyzer: SlideTemplateAnalyzing, fileImporter: FileImporting) {
        self.analyzer = analyzer
        self.fileImporter = fileImporter
        super.init()
        
        // 设置自动保存
        setupAutosave()
    }
    
    // 用户操作 - 导入模板
    func importTemplate() async {
        // 实际应用中这里应该使用UIDocument或NSOpenPanel
        // 为了演示，这里提供一个简化的实现
        
        // 示例：使用文件选择器
        #if os(iOS)
        // iOS实现代码
        #elseif os(macOS)
        // macOS实现代码
        #endif
        
        // 演示目的，模拟文件选择
        guard let testFileURL = Bundle.main.url(forResource: "SampleTemplate", withExtension: "pptx") else {
            await MainActor.run {
                self.errorMessage = "测试模板文件未找到"
                self.hasError = true
            }
            return
        }
        
        do {
            let document = try await fileImporter.importTemplateFile(from: testFileURL)
            await MainActor.run {
                self.importedDocument = document
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "导入失败: \(error.localizedDescription)"
                self.hasError = true
            }
        }
    }
    
    // 开始分析
    func startAnalysis() async {
        guard let document = importedDocument else { return }
        
        // 启动进度更新
        startProgressTracking()
        
        // 使用通用任务执行框架
        _ = await performTask {
            let result = try await analyzer.analyzeTemplate(document: document)
            
            // 主线程更新UI状态
            await MainActor.run {
                self.analysisResult = result
                self.extractedStyles = result.styleElements
            }
            
            return result
        }
        
        // 停止进度跟踪
        stopProgressTracking()
    }
    
    // 保存模板
    func saveTemplate() async throws {
        guard let result = analysisResult else { throw AnalysisError.noResultAvailable }
        
        // 保存模板到Core模块
        // 这里应该调用仓库层
        print("保存模板: \(result)")
        
        // 示例实现...
    }
    
    // 私有辅助方法 - 启动进度跟踪
    private func startProgressTracking() {
        stopProgressTracking() // 确保先停止之前的计时器
        
        // 在主线程上创建计时器
        DispatchQueue.main.async {
            self.progressTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { [weak self] _ in
                guard let self = self else { return }
                let currentProgress = self.analyzer.currentProgress()
                self.analysisProgress = currentProgress
                
                // 如果进度为1，停止计时器
                if currentProgress >= 1.0 {
                    self.stopProgressTracking()
                }
            }
        }
    }
    
    // 停止进度跟踪
    private func stopProgressTracking() {
        DispatchQueue.main.async {
            self.progressTimer?.invalidate()
            self.progressTimer = nil
        }
    }
    
    // 设置自动保存
    private func setupAutosave() {
        // 示例：观察分析结果变化，触发自动保存
        $analysisResult
            .debounce(for: .seconds(2), scheduler: RunLoop.main)
            .sink { [weak self] result in
                guard let result = result else { return }
                Task {
                    try? await self?.saveTemplate()
                }
            }
            .store(in: &cancellables)
    }
    
    deinit {
        stopProgressTracking()
        cancellables.forEach { $0.cancel() }
    }
}

enum AnalysisError: Error {
    case noResultAvailable
    case saveFailed
}
```

### 3.2 SwiftUI视图实现

```swift
// OnlySlideUI/Sources/Views/Analysis/TemplateAnalysisView.swift
import SwiftUI
import OnlySlideCore

struct TemplateAnalysisView: View {
    @StateObject var viewModel: TemplateAnalysisViewModel
    @Environment(\.colorScheme) var colorScheme
    
    init(analyzer: SlideTemplateAnalyzing, fileImporter: FileImporting) {
        _viewModel = StateObject(wrappedValue: TemplateAnalysisViewModel(
            analyzer: analyzer, 
            fileImporter: fileImporter
        ))
    }
    
    var body: some View {
        NavigationStack {
            content
                .navigationTitle("模板分析")
                .toolbar {
                    ToolbarItem(placement: .primaryAction) {
                        importButton
                    }
                }
                .alert("错误", isPresented: $viewModel.hasError) {
                    Button("确定", role: .cancel) {}
                } message: {
                    Text(viewModel.errorMessage ?? "未知错误")
                }
        }
        #if os(macOS)
        .frame(minWidth: 700, minHeight: 600)
        #endif
    }
    
    private var content: some View {
        Group {
            if viewModel.isLoading {
                loadingView
            } else if viewModel.importedDocument != nil && viewModel.analysisResult == nil {
                documentReadyView
            } else if let result = viewModel.analysisResult {
                analysisResultView(result)
            } else {
                emptyStateView
            }
        }
    }
    
    private var loadingView: some View {
        VStack(spacing: 20) {
            ProgressView()
                .progressViewStyle(.circular)
                .scaleEffect(1.5)
            
            Text("分析中... \(Int(viewModel.analysisProgress * 100))%")
                .font(.headline)
        }
    }
    
    private var documentReadyView: some View {
        VStack(spacing: 20) {
            Text("已导入模板：\(viewModel.importedDocument?.name ?? "")")
                .font(.headline)
            
            Button("开始分析") {
                Task {
                    await viewModel.startAnalysis()
                }
            }
            .buttonStyle(.borderedProminent)
            .controlSize(.large)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    private var emptyStateView: some View {
        VStack(spacing: 25) {
            Image(systemName: "doc.viewfinder")
                .font(.system(size: 60))
                .foregroundColor(.secondary)
            
            Text("导入PPT模板开始分析")
                .font(.title2)
            
            Button("导入模板") {
                Task {
                    await viewModel.importTemplate()
                }
            }
            .buttonStyle(.borderedProminent)
            .controlSize(.large)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    private func analysisResultView(_ result: TemplateAnalysisResult) -> some View {
        VStack {
            // 分析结果头部信息
            HStack {
                VStack(alignment: .leading) {
                    Text("分析完成")
                        .font(.headline)
                    Text("从模板中提取了\(viewModel.extractedStyles.count)个样式元素")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                Spacer()
                Button("保存模板") {
                    Task {
                        try await viewModel.saveTemplate()
                    }
                }
                .buttonStyle(.borderedProminent)
            }
            .padding()
            
            // 提取的风格元素展示
            ScrollView {
                LazyVGrid(columns: [GridItem(.adaptive(minimum: 160))], spacing: 16) {
                    ForEach(viewModel.extractedStyles) { style in
                        styleElementCard(style)
                    }
                }
                .padding()
            }
        }
    }
    
    private func styleElementCard(_ style: StyleElement) -> some View {
        VStack(alignment: .leading) {
            // 样式元素预览
            RoundedRectangle(cornerRadius: 8)
                .fill(style.previewColor)
                .frame(height: 80)
                .overlay(
                    Text(style.type.rawValue.capitalized)
                        .font(.caption)
                        .foregroundColor(style.previewColor.contrastColor)
                        .padding(6)
                )
            
            // 样式元素信息
            VStack(alignment: .leading, spacing: 4) {
                Text(style.name)
                    .font(.headline)
                    .lineLimit(1)
                
                Text(style.description)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(2)
            }
            .padding(.vertical, 8)
        }
        .padding(12)
        .background(Color.systemBackground)
        .cornerRadius(12)
        .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
    }
    
    private var importButton: some View {
        Button {
            Task {
                await viewModel.importTemplate()
            }
        } label: {
            Label("导入", systemImage: "square.and.arrow.down")
        }
    }
}

// 支持深色模式的辅助扩展
extension Color {
    var contrastColor: Color {
        // 简单的对比色算法，复杂实现可以分析亮度
        return self.brightness > 0.6 ? .black : .white
    }
    
    var brightness: CGFloat {
        guard let components = cgColor?.components, components.count >= 3 else {
            return 0
        }
        return ((components[0] * 299) + (components[1] * 587) + (components[2] * 114)) / 1000
    }
    
    static var systemBackground: Color {
        #if os(iOS)
        return Color(UIColor.systemBackground)
        #elseif os(macOS)
        return Color(NSColor.windowBackgroundColor)
        #endif
    }
}

// 扩展StyleElement以提供预览颜色
extension StyleElement {
    var previewColor: Color {
        switch self.type {
        case .color:
            return Color(red: self.colorValue?.red ?? 0, 
                        green: self.colorValue?.green ?? 0, 
                        blue: self.colorValue?.blue ?? 0)
        case .font:
            return .blue.opacity(0.7)
        case .layout:
            return .purple.opacity(0.7)
        case .spacing:
            return .orange.opacity(0.7)
        }
    }
}
```

### 3.3 平台适配实现

```swift
// OnlySlideUI/Sources/PlatformAdapters/PlatformAdapter.swift
import SwiftUI
import UniformTypeIdentifiers

/// 定义平台特定功能的接口
public protocol PlatformAdapter {
    /// 显示文件选择器以导入文件
    /// - Parameters:
    ///   - contentTypes: 允许的文件类型
    ///   - allowMultiple: 是否允许多选
    ///   - completion: 完成回调，传递所选文件的URL
    func showFileImporter(contentTypes: [UTType], allowMultiple: Bool, completion: @escaping ([URL]) -> Void)
    
    /// 显示文件选择器以导出文件
    /// - Parameters:
    ///   - suggestedName: 建议的文件名
    ///   - contentType: 文件类型
    ///   - data: 要保存的数据
    ///   - completion: 完成回调，表示成功或失败
    func showFileExporter(suggestedName: String, contentType: UTType, data: Data, completion: @escaping (Bool) -> Void)
    
    /// 执行平台特定的共享功能
    /// - Parameters:
    ///   - items: 要共享的内容
    ///   - completion: 完成回调
    func shareItems(_ items: [Any], completion: @escaping (Bool) -> Void)
    
    /// 获取平台特定的键盘快捷键
    func getKeyboardShortcuts() -> [KeyboardShortcut]
    
    /// 是否支持平台特定功能
    func supportsFeature(_ feature: PlatformFeature) -> Bool
}

/// 平台特定功能
public enum PlatformFeature {
    case dragAndDrop
    case splitView
    case pencilInput
    case multiWindow
    case systemMenus
}

// OnlySlideUI/Sources/PlatformAdapters/iOSAdapter.swift
#if os(iOS)
import SwiftUI
import UIKit
import UniformTypeIdentifiers

public class iOSAdapter: NSObject, PlatformAdapter, UIDocumentPickerDelegate {
    private var fileImportCompletion: (([URL]) -> Void)?
    
    public func showFileImporter(contentTypes: [UTType], allowMultiple: Bool, completion: @escaping ([URL]) -> Void) {
        self.fileImportCompletion = completion
        
        // 获取当前最顶层的视图控制器
        guard let rootViewController = UIApplication.shared.windows.first?.rootViewController else {
            completion([])
            return
        }
        
        // 创建文件选择器
        let documentPicker = UIDocumentPickerViewController(forOpeningContentTypes: contentTypes, asCopy: true)
        documentPicker.delegate = self
        documentPicker.allowsMultipleSelection = allowMultiple
        
        rootViewController.present(documentPicker, animated: true, completion: nil)
    }
    
    public func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
        // 使用securityScoped URLs
        for url in urls {
            guard url.startAccessingSecurityScopedResource() else { continue }
            defer { url.stopAccessingSecurityScopedResource() }
            // 文件处理逻辑
        }
        
        fileImportCompletion?(urls)
        fileImportCompletion = nil
    }
    
    public func documentPickerWasCancelled(_ controller: UIDocumentPickerViewController) {
        fileImportCompletion?([])
        fileImportCompletion = nil
    }
    
    public func showFileExporter(suggestedName: String, contentType: UTType, data: Data, completion: @escaping (Bool) -> Void) {
        // iOS文件导出实现
        // 使用UIActivityViewController
        
        // 创建临时文件
        let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent(suggestedName)
        
        do {
            try data.write(to: tempURL)
            
            // 创建分享控制器
            let activityViewController = UIActivityViewController(activityItems: [tempURL], applicationActivities: nil)
            
            // 设置完成处理程序
            activityViewController.completionWithItemsHandler = { _, success, _, _ in
                // 导出完成后清理临时文件
                try? FileManager.default.removeItem(at: tempURL)
                completion(success)
            }
            
            // 显示分享控制器
            guard let rootViewController = UIApplication.shared.windows.first?.rootViewController else {
                completion(false)
                return
            }
            
            rootViewController.present(activityViewController, animated: true, completion: nil)
            
        } catch {
            print("Failed to export file: \(error)")
            completion(false)
        }
    }
    
    public func shareItems(_ items: [Any], completion: @escaping (Bool) -> Void) {
        let activityViewController = UIActivityViewController(activityItems: items, applicationActivities: nil)
        
        activityViewController.completionWithItemsHandler = { _, success, _, _ in
            completion(success)
        }
        
        guard let rootViewController = UIApplication.shared.windows.first?.rootViewController else {
            completion(false)
            return
        }
        
        rootViewController.present(activityViewController, animated: true, completion: nil)
    }
    
    public func getKeyboardShortcuts() -> [KeyboardShortcut] {
        // iOS键盘快捷键实现 (iPad外接键盘)
        return [
            KeyboardShortcut(.return, modifiers: [.command], action: #selector(UIResponder.insertNewline(_:))),
            KeyboardShortcut("s", modifiers: [.command], action: #selector(UIResponder.copy(_:)))
        ]
    }
    
    public func supportsFeature(_ feature: PlatformFeature) -> Bool {
        switch feature {
        case .dragAndDrop:
            return true
        case .splitView:
            return true // iPad支持
        case .pencilInput:
            return true // iPad支持
        case .multiWindow:
            return UIDevice.current.userInterfaceIdiom == .pad
        case .systemMenus:
            return false
        }

## 4. 核心功能实现

### 4.1 幻灯片内容生成功能

```language=swift
// OnlySlideCore/Sources/Services/Generation/SlideGenerationService.swift
import Foundation
import Combine

public class SlideGenerationService: SlideGenerating {
    private var generationTask: Task<Void, Never>?
    private var progressSubject = CurrentValueSubject<Double, Never>(0.0)
    
    public init() {}
    
    public func generateSlides(content: StructuredContent, 
                              styleModel: StyleModel) async throws -> GeneratedPresentation {
        // 取消之前可能正在运行的任务
        cancelGeneration()
        
        // 创建新任务
        return try await withCheckedThrowingContinuation { continuation in
            generationTask = Task {
                do {
                    // 内容分析与预处理
                    progressSubject.send(0.2)
                    let analyzedContent = try await analyzeContentStructure(content)
                    
                    // 应用样式
                    progressSubject.send(0.4)
                    let styledContent = try await applyStyle(analyzedContent, styleModel: styleModel)
                    
                    // 生成幻灯片
                    progressSubject.send(0.6)
                    let slides = try await buildSlides(styledContent)
                    
                    // 后处理优化
                    progressSubject.send(0.8)
                    let optimizedSlides = try await optimizeSlides(slides)
                    
                    // 创建最终演示文稿
                    progressSubject.send(0.9)
                    let presentation = GeneratedPresentation(
                        id: UUID(),
                        title: content.title ?? "Untitled Presentation",
                        slides: optimizedSlides,
                        styleModel: styleModel,
                        createdAt: Date()
                    )
                    
                    progressSubject.send(1.0)
                    continuation.resume(returning: presentation)
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    
    public func generationProgress() -> Double {
        return progressSubject.value
    }
    
    public func cancelGeneration() {
        generationTask?.cancel()
        generationTask = nil
        progressSubject.send(0.0)
    }
    
    // MARK: - 私有辅助方法
    
    private func analyzeContentStructure(_ content: StructuredContent) async throws -> AnalyzedContent {
        // 分析内容结构，确定主题和关键点
        // 实际实现将使用更复杂的算法
        return AnalyzedContent(sections: content.sections, theme: content.theme ?? "Default")
    }
    
    private func applyStyle(_ content: AnalyzedContent, styleModel: StyleModel) async throws -> StyledContent {
        // 将样式应用到内容上
        return StyledContent(content: content, styleModel: styleModel)
    }
    
    private func buildSlides(_ styledContent: StyledContent) async throws -> [Slide] {
        // 根据样式化内容构建幻灯片
        var slides: [Slide] = []
        
        // 创建标题幻灯片
        slides.append(Slide(
            id: UUID(),
            type: .title,
            title: styledContent.content.title ?? "Untitled",
            content: [],
            style: styledContent.styleModel,
            index: 0
        ))
        
        // 为每个部分创建内容幻灯片
        for (index, section) in styledContent.content.sections.enumerated() {
            let slide = Slide(
                id: UUID(),
                type: .content,
                title: section.title,
                content: section.points,
                style: styledContent.styleModel,
                index: index + 1
            )
            slides.append(slide)
        }
        
        return slides
    }
    
    private func optimizeSlides(_ slides: [Slide]) async throws -> [Slide] {
        // 优化幻灯片，例如平衡内容分布等
        return slides
    }
}
```

### 4.2 文档分析与处理引擎

```language=swift
// OnlySlideCore/Sources/Services/Analysis/DocumentAnalysisService.swift
import Foundation
import NaturalLanguage

public class DocumentAnalysisService: DocumentAnalyzing {
    private var analysisTask: Task<Void, Never>?
    private var progressSubject = CurrentValueSubject<Double, Never>(0.0)
    
    public init() {}
    
    public func analyzeDocument(_ document: ImportedDocument) async throws -> StructuredContent {
        // 取消先前的分析任务
        cancelAnalysis()
        
        return try await withCheckedThrowingContinuation { continuation in
            analysisTask = Task {
                do {
                    // 提取文本内容
                    progressSubject.send(0.1)
                    let textContent = try extractText(from: document)
                    
                    // 解析文档结构
                    progressSubject.send(0.3)
                    let documentStructure = try parseDocumentStructure(textContent)
                    
                    // 识别主题和关键点
                    progressSubject.send(0.5)
                    let (title, theme) = try identifyThemeAndTitle(documentStructure)
                    
                    // 提取章节和要点
                    progressSubject.send(0.7)
                    let sections = try extractSections(documentStructure)
                    
                    // 优化结构化内容
                    progressSubject.send(0.9)
                    let structuredContent = StructuredContent(
                        title: title,
                        theme: theme,
                        sections: sections,
                        originalDocument: document
                    )
                    
                    progressSubject.send(1.0)
                    continuation.resume(returning: structuredContent)
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    
    public func analysisProgress() -> Double {
        return progressSubject.value
    }
    
    public func cancelAnalysis() {
        analysisTask?.cancel()
        analysisTask = nil
        progressSubject.send(0.0)
    }
    
    // MARK: - 私有辅助方法
    
    private func extractText(from document: ImportedDocument) throws -> String {
        // 根据文档类型提取文本
        switch document.fileType {
        case .pdf:
            return try extractTextFromPDF(document.data)
        case .docx:
            return try extractTextFromDOCX(document.data)
        case .txt:
            guard let text = String(data: document.data, encoding: .utf8) else {
                throw AnalysisError.textExtractionFailed
            }
            return text
        default:
            throw AnalysisError.unsupportedFileType
        }
    }
    
    private func parseDocumentStructure(_ text: String) throws -> [DocumentElement] {
        // 将文本解析为结构化元素（标题、段落、列表等）
        var elements: [DocumentElement] = []
        
        // 简化版：实际实现会更复杂
        let lines = text.components(separatedBy: .newlines)
        
        for line in lines where !line.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            if line.hasPrefix("#") {
                // 标题
                let title = line.trimmingCharacters(in: CharacterSet(charactersIn: "# "))
                elements.append(.heading(title, level: 1))
            } else if line.hasPrefix("- ") || line.hasPrefix("* ") {
                // 列表项
                let item = line.dropFirst(2).trimmingCharacters(in: .whitespaces)
                elements.append(.listItem(item))
            } else {
                // 段落
                elements.append(.paragraph(line))
            }
        }
        
        return elements
    }
    
    private func identifyThemeAndTitle(_ elements: [DocumentElement]) throws -> (String, String?) {
        // 识别文档标题和主题
        let title = elements.compactMap { element -> String? in
            if case .heading(let text, let level) = element, level == 1 {
                return text
            }
            return nil
        }.first ?? "Untitled Presentation"
        
        // 简单主题检测 - 实际实现会使用更复杂的NLP
        let allText = elements.compactMap { element -> String? in
            switch element {
            case .paragraph(let text): return text
            case .heading(let text, _): return text
            case .listItem(let text): return text
            default: return nil
            }
        }.joined(separator: " ")
        
        // 使用NLP进行主题识别
        let tagger = NLTagger(tagSchemes: [.nameType])
        tagger.string = allText
        
        var potentialThemes: [String: Int] = [:]
        
        tagger.enumerateTags(in: allText.startIndex..<allText.endIndex, 
                            unit: .word, 
                            scheme: .nameType) { tag, range in
            if let tag = tag, tag == .personalName || tag == .organizationName || tag == .placeName {
                let word = String(allText[range])
                potentialThemes[word, default: 0] += 1
            }
            return true
        }
        
        // 返回出现频率最高的潜在主题
        let theme = potentialThemes.max(by: { $0.value < $1.value })?.key
        
        return (title, theme)
    }
    
    private func extractSections(_ elements: [DocumentElement]) throws -> [ContentSection] {
        // 从文档元素提取章节和要点
        var sections: [ContentSection] = []
        var currentSection: ContentSection?
        var currentPoints: [String] = []
        
        for element in elements {
            switch element {
            case .heading(let text, let level) where level == 2:
                // 保存之前的章节并开始新章节
                if let section = currentSection {
                    sections.append(ContentSection(
                        title: section.title,
                        points: currentPoints
                    ))
                }
                currentSection = ContentSection(title: text, points: [])
                currentPoints = []
                
            case .listItem(let text):
                currentPoints.append(text)
                
            case .paragraph(let text) where currentSection != nil && currentPoints.isEmpty:
                // 将段落作为章节的第一个要点
                currentPoints.append(text)
                
            default:
                break
            }
        }
        
        // 添加最后一个章节
        if let section = currentSection {
            sections.append(ContentSection(
                title: section.title,
                points: currentPoints
            ))
        }
        
        return sections
    }
    
    // 提取不同文档类型的文本
    private func extractTextFromPDF(_ data: Data) throws -> String {
        // PDF文本提取逻辑
        // 实际项目中使用PDFKit或第三方库
        return "PDF文本内容示例"
    }
    
    private func extractTextFromDOCX(_ data: Data) throws -> String {
        // DOCX文本提取逻辑
        return "DOCX文本内容示例"
    }
}

// 文档分析错误类型
public enum AnalysisError: Error {
    case textExtractionFailed
    case unsupportedFileType
    case parseError
    case noContentFound
}

// 文档元素类型
enum DocumentElement {
    case heading(String, level: Int)
    case paragraph(String)
    case listItem(String)
    case image(Data, caption: String?)
    case table([[String]])
}
```

## 5. 用户界面组件

### 5.1 幻灯片编辑视图

```language=swift
// OnlySlideUI/Sources/Views/Editor/SlideEditorView.swift
import SwiftUI
import OnlySlideCore

struct SlideEditorView: View {
    @ObservedObject var viewModel: SlideEditorViewModel
    @State private var selectedSlideIndex: Int = 0
    @State private var isPresentingStyleEditor = false
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        GeometryReader { geometry in
            HStack(spacing: 0) {
                // 左侧幻灯片缩略图栏
                SlideNavigatorView(
                    slides: viewModel.presentation.slides,
                    selectedIndex: $selectedSlideIndex,
                    onSelectSlide: { index in
                        selectedSlideIndex = index
                        viewModel.selectSlide(at: index)
                    }
                )
                .frame(width: geometry.size.width * 0.2)
                .background(Color(colorScheme == .dark ? .secondarySystemBackground : .systemGray6))
                
                // 主编辑区域
                VStack {
                    // 工具栏
                    SlideEditorToolbar(
                        viewModel: viewModel,
                        onStyleEdit: { isPresentingStyleEditor = true }
                    )
                    .padding()
                    
                    // 当前幻灯片编辑视图
                    if let currentSlide = viewModel.currentSlide {
                        SlideCanvas(
                            slide: currentSlide,
                            styleModel: viewModel.presentation.styleModel,
                            onContentUpdated: { updatedSlide in
                                viewModel.updateSlide(updatedSlide)
                            }
                        )
                        .padding()
                        .background(Color(colorScheme == .dark ? .systemBackground : .systemGray5))
                        .cornerRadius(8)
                        .shadow(radius: 2)
                    } else {
                        Text("No slide selected")
                            .font(.title)
                            .foregroundColor(.secondary)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                    }
                }
                .padding()
                .frame(width: geometry.size.width * 0.8)
            }
        }
        .sheet(isPresented: $isPresentingStyleEditor) {
            StyleEditorView(
                styleModel: viewModel.presentation.styleModel,
                onStyleUpdated: { updatedStyle in
                    viewModel.updateStyle(updatedStyle)
                }
            )
            .frame(minWidth: 600, minHeight: 500)
        }
        .toolbar {
            ToolbarItem(placement: .primaryAction) {
                Button(action: {
                    viewModel.savePresentation()
                }) {
                    Label("Save", systemImage: "square.and.arrow.down")
                }
            }
            
            ToolbarItem(placement: .primaryAction) {
                Button(action: {
                    viewModel.exportPresentation()
                }) {
                    Label("Export", systemImage: "arrow.up.doc")
                }
            }
        }
        .alert(isPresented: $viewModel.hasError) {
            Alert(
                title: Text("Error"),
                message: Text(viewModel.errorMessage ?? "An unknown error occurred"),
                dismissButton: .default(Text("OK"))
            )
        }
        .onAppear {
            viewModel.loadPresentation()
        }
    }
}

// 幻灯片画布视图
struct SlideCanvas: View {
    var slide: Slide
    var styleModel: StyleModel
    var onContentUpdated: (Slide) -> Void
    
    @State private var editingTitle: Bool = false
    @State private var editingContent: Bool = false
    @State private var tempTitle: String = ""
    @State private var tempContent: [String] = []
    
    var body: some View {
        VStack(spacing: 20) {
            // 幻灯片标题
            if editingTitle {
                TextField("Enter title", text: $tempTitle, onCommit: {
                    var updatedSlide = slide
                    updatedSlide.title = tempTitle
                    onContentUpdated(updatedSlide)
                    editingTitle = false
                })
                .font(.system(size: CGFloat(styleModel.titleFontSize), weight: fontWeightFrom(styleModel.titleFontWeight)))
                .foregroundColor(Color(styleModel.titleColor))
                .multilineTextAlignment(.center)
                .padding()
            } else {
                Text(slide.title)
                    .font(.system(size: CGFloat(styleModel.titleFontSize), weight: fontWeightFrom(styleModel.titleFontWeight)))
                    .foregroundColor(Color(styleModel.titleColor))
                    .multilineTextAlignment(.center)
                    .padding()
                    .onTapGesture {
                        tempTitle = slide.title
                        editingTitle = true
                    }
            }
            
            // 幻灯片内容
            if slide.type != .title {
                VStack(alignment: .leading, spacing: 15) {
                    ForEach(Array(slide.content.enumerated()), id: \.element) { index, point in
                        if editingContent && tempContent.indices.contains(index) {
                            HStack {
                                TextField("Point content", text: $tempContent[index])
                                    .font(.system(size: CGFloat(styleModel.contentFontSize), 
                                                 weight: fontWeightFrom(styleModel.contentFontWeight)))
                                    .foregroundColor(Color(styleModel.contentColor))
                                
                                Button(action: {
                                    tempContent.remove(at: index)
                                }) {
                                    Image(systemName: "minus.circle.fill")
                                        .foregroundColor(.red)
                                }
                            }
                        } else {
                            HStack {
                                Image(systemName: styleModel.bulletStyle.systemImageName)
                                    .foregroundColor(Color(styleModel.accentColor))
                                
                                Text(point)
                                    .font(.system(size: CGFloat(styleModel.contentFontSize), 
                                                 weight: fontWeightFrom(styleModel.contentFontWeight)))
                                    .foregroundColor(Color(styleModel.contentColor))
                            }
                            .contentShape(Rectangle())
                            .onTapGesture {
                                tempContent = slide.content
                                editingContent = true
                            }
                        }
                    }
                    
                    if editingContent {
                        Button(action: {
                            tempContent.append("New point")
                        }) {
                            Label("Add Point", systemImage: "plus.circle.fill")
                                .foregroundColor(Color(styleModel.accentColor))
                        }
                        .padding(.top, 5)
                        
                        HStack {
                            Button("Save") {
                                var updatedSlide = slide
                                updatedSlide.content = tempContent
                                onContentUpdated(updatedSlide)
                                editingContent = false
                            }
                            .buttonStyle(.borderedProminent)
                            
                            Button("Cancel") {
                                editingContent = false
                            }
                            .buttonStyle(.bordered)
                        }
                        .padding(.top, 10)
                    }
                }
                .padding()
                .frame(maxWidth: .infinity, alignment: .leading)
            }
        }
        .padding(20)
        .background(Color(styleModel.backgroundColor))
        .cornerRadius(10)
    }
    
    private func fontWeightFrom(_ weight: FontWeight) -> Font.Weight {
        switch weight {
        case .ultraLight: return .ultraLight
        case .thin: return .thin
        case .light: return .light
        case .regular: return .regular
        case .medium: return .medium
        case .semibold: return .semibold
        case .bold: return .bold
        case .heavy: return .heavy
        case .black: return .black
        }
    }
}
```

### 5.2 预览和演示模式

```language=swift
// OnlySlideUI/Sources/Views/Presentation/PresentationView.swift
import SwiftUI
import OnlySlideCore

struct PresentationView: View {
    @ObservedObject var viewModel: PresentationViewModel
    @State private var currentSlideIndex = 0
    @State private var isFullScreen = false
    @State private var transitionType: SlideTransition = .fade
    @Environment(\.presentationMode) var presentationMode
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // 背景
                Color(viewModel.presentation.styleModel.backgroundColor)
                    .edgesIgnoringSafeArea(.all)
                
                VStack {
                    if !isFullScreen {
                        // 控制栏
                        PresentationControlBar(
                            currentSlideIndex: $currentSlideIndex,
                            totalSlides: viewModel.presentation.slides.count,
                            isFullScreen: $isFullScreen,
                            onTransitionChanged: { newTransition in
                                transitionType = newTransition
                            },
                            onExit: {
                                presentationMode.wrappedValue.dismiss()
                            }
                        )
                        .padding()
                    }
                    
                    // 幻灯片内容
                    SlideView(
                        slide: viewModel.presentation.slides[currentSlideIndex],
                        styleModel: viewModel.presentation.styleModel
                    )
                    .frame(maxWidth: geometry.size.width * 0.8, maxHeight: geometry.size.height * 0.8)
                    .transition(transitionEffect(for: transitionType))
                    .id(currentSlideIndex) // 确保转场动画正常工作
                    
                    Spacer()
                }
                
                // 全屏模式下的导航覆盖层
                if isFullScreen {
                    HStack {
                        // 左侧点击区域 - 前一张幻灯片
                        Color.clear
                            .contentShape(Rectangle())
                            .onTapGesture {
                                withAnimation {
                                    if currentSlideIndex > 0 {
                                        currentSlideIndex -= 1
                                    }
                                }
                            }
                        
                        // 右侧点击区域 - 下一张幻灯片
                        Color.clear
                            .contentShape(Rectangle())
                            .onTapGesture {
                                withAnimation {
                                    if currentSlideIndex < viewModel.presentation.slides.count - 1 {
                                        currentSlideIndex += 1
                                    }
                                }
                            }
                    }
                    
                    // 退出全屏模式的手势区域
                    VStack {
                        Color.clear
                            .frame(height: 40)
                            .contentShape(Rectangle())
                            .onTapGesture {
                                isFullScreen = false
                            }
                        Spacer()
                    }
                }
            }
            .onAppear {
                viewModel.preparePresentation()
            }
            .onDisappear {
                viewModel.endPresentation()
            }
            .keyCommands([
                KeyCommand(input: UIKeyCommand.inputRightArrow, modifiers: [], action: #selector(nextSlide)),
                KeyCommand(input: UIKeyCommand.inputLeftArrow, modifiers: [], action: #selector(previousSlide)),
                KeyCommand(input: "f", modifiers: .command, action: #selector(toggleFullScreen)),
                KeyCommand(input: UIKeyCommand.inputEscape, modifiers: [], action: #selector(exitPresentation))
            ])
        }
    }
    
    private func transitionEffect(for type: SlideTransition) -> AnyTransition {
        switch type {
        case .fade:
            return AnyTransition.opacity.animation(.easeInOut(duration: 0.5))
        case .slide:
            return AnyTransition.asymmetric(
                insertion: .move(edge: .trailing).combined(with: .opacity),
                removal: .move(edge: .leading).combined(with: .opacity)
            ).animation(.easeInOut(duration: 0.5))
        case .zoom:
            return AnyTransition.scale.combined(with: .opacity).animation(.easeInOut(duration: 0.5))
        }
    }
    
    @objc func nextSlide() {
        withAnimation {
            if currentSlideIndex < viewModel.presentation.slides.count - 1 {
                currentSlideIndex += 1
            }
        }
    }
    
    @objc func previousSlide() {
        withAnimation {
            if currentSlideIndex > 0 {
                currentSlideIndex -= 1
            }
        }
    }
    
    @objc func toggleFullScreen() {
        isFullScreen.toggle()
    }
    
    @objc func exitPresentation() {
        if isFullScreen {
            isFullScreen = false
        } else {
            presentationMode.wrappedValue.dismiss()
        }
    }
}

// 幻灯片转场类型
enum SlideTransition {
    case fade
    case slide
    case zoom
}

struct SlideView: View {
    var slide: Slide
    var styleModel: StyleModel
    
    var body: some View {
        VStack(spacing: 24) {
            // 标题
            Text(slide.title)
                .font(.system(size: CGFloat(styleModel.titleFontSize), weight: fontWeightFrom(styleModel.titleFontWeight)))
                .foregroundColor(Color(styleModel.titleColor))
                .multilineTextAlignment(.center)
                .padding(.top, 40)
                .padding(.bottom, 20)
            
            // 内容
            if slide.type != .title {
                VStack(alignment: .leading, spacing: 18) {
                    ForEach(slide.content, id: \.self) { point in
                        HStack(alignment: .top, spacing: 12) {
                            Image(systemName: styleModel.bulletStyle.systemImageName)
                                .foregroundColor(Color(styleModel.accentColor))
                                .font(.system(size: CGFloat(styleModel.contentFontSize) * 0.7))
                                .frame(width: 24, alignment: .center)
                            
                            Text(point)
                                .font(.system(size: CGFloat(styleModel.contentFontSize), weight: fontWeightFrom(styleModel.contentFontWeight)))
                                .foregroundColor(Color(styleModel.contentColor))
                                .fixedSize(horizontal: false, vertical: true)
                        }
                        .padding(.horizontal, 40)
                        .transition(.opacity.combined(with: .move(edge: .trailing)))
                        .id(point) // 确保每个点可以独立动画
                    }
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 30)
            }
            
            Spacer()
            
            // 幻灯片页脚
            if styleModel.showFooter {
                HStack {
                    Text(styleModel.footerText ?? "")
                        .font(.caption)
                        .foregroundColor(Color(styleModel.footerColor))
                    
                    Spacer()
                    
                    Text("\(slide.index + 1)")
                        .font(.caption)
                        .foregroundColor(Color(styleModel.footerColor))
                }
                .padding(.horizontal, 40)
                .padding(.bottom, 16)
            }
        }
        .background(Color(styleModel.backgroundColor))
        .cornerRadius(8)
        .shadow(radius: 4)
    }
    
    private func fontWeightFrom(_ weight: FontWeight) -> Font.Weight {
        switch weight {
        case .ultraLight: return .ultraLight
        case .thin: return .thin
        case .light: return .light
        case .regular: return .regular
        case .medium: return .medium
        case .semibold: return .semibold
        case .bold: return .bold
        case .heavy: return .heavy
        case .black: return .black
        }
    }
}
```

## 6. 导出与分享

```language=swift
// OnlySlideCore/Sources/Services/Export/PresentationExportService.swift
import Foundation
import PDFKit
import UIKit

public class PresentationExportService: PresentationExporting {
    private let fileManager = FileManager.default
    
    public init() {}
    
    public func exportAsPDF(presentation: GeneratedPresentation) async throws -> URL {
        // 创建临时目录
        let tempDirURL = fileManager.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try fileManager.createDirectory(at: tempDirURL, withIntermediateDirectories: true)
        
        // 创建PDF文件路径
        let fileName = presentation.title.isEmpty ? "Presentation" : presentation.title
        let sanitizedFileName = fileName.replacingOccurrences(of: " ", with: "_")
                                       .replacingOccurrences(of: "/", with: "_")
        let pdfURL = tempDirURL.appendingPathComponent("\(sanitizedFileName).pdf")
        
        // 渲染幻灯片到PDF
        let pdfDocument = PDFDocument()
        
        // 为每张幻灯片创建PDF页面
        for slide in presentation.slides {
            let slideImage = try await renderSlideAsImage(slide, styleModel: presentation.styleModel)
            guard let pdfPage = PDFPage(image: slideImage) else {
                throw ExportError.pdfPageCreationFailed
            }
            pdfDocument.insert(pdfPage, at: pdfDocument.pageCount)
        }
        
        // 保存PDF文件
        guard pdfDocument.write(to: pdfURL) else {
            throw ExportError.pdfWriteFailed
        }
        
        return pdfURL
    }
    
    public func exportAsPNG(presentation: GeneratedPresentation) async throws -> [URL] {
        // 创建临时目录
        let tempDirURL = fileManager.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try fileManager.createDirectory(at: tempDirURL, withIntermediateDirectories: true)
        
        var imageURLs: [URL] = []
        
        // 为每张幻灯片创建PNG图像
        for (index, slide) in presentation.slides.enumerated() {
            let slideImage = try await renderSlideAsImage(slide, styleModel: presentation.styleModel)
            
            // 保存为PNG
            let imageURL = tempDirURL.appendingPathComponent("slide_\(index + 1).png")
            guard let imageData = slideImage.pngData() else {
                throw ExportError.imageDataGenerationFailed
            }
            
            try imageData.write(to: imageURL)
            imageURLs.append(imageURL)
        }
        
        return imageURLs
    }
    
    public func sharePresentation(_ presentation: GeneratedPresentation, with recipient: String) async throws {
        // 实现分享功能逻辑
        // 这里通常会与特定平台的共享机制集成
        // 例如：电子邮件、消息、云存储服务等
        
        let pdfURL = try await exportAsPDF(presentation: presentation)
        
        // 示例：发送电子邮件
        // 实际实现依赖于应用的需求
        
        // 模拟分享成功
        return
    }
    
    // MARK: - 私有辅助方法
    
    private func renderSlideAsImage(_ slide: Slide, styleModel: StyleModel) async throws -> UIImage {
        return try await withCheckedThrowingContinuation { continuation in
            // 在主线程上执行UI渲染
            DispatchQueue.main.async {
                // 创建渲染上下文
                let renderer = UIGraphicsImageRenderer(size: CGSize(width: 1920, height: 1080))
                
                let image = renderer.image { context in
                    // 渲染背景
                    let backgroundColor = UIColor(styleModel.backgroundColor)
                    backgroundColor.setFill()
                    context.fill(CGRect(x: 0, y: 0, width: 1920, height: 1080))
                    
                    // 渲染标题
                    let titleAttributes: [NSAttributedString.Key: Any] = [
                        .font: UIFont.systemFont(ofSize: CGFloat(styleModel.titleFontSize), weight: self.fontWeightFrom(styleModel.titleFontWeight)),
                        .foregroundColor: UIColor(styleModel.titleColor)
                    ]
                    
                    let titleString = slide.title as NSString
                    let titleSize = titleString.size(withAttributes: titleAttributes)
                    let titleRect = CGRect(x: (1920 - titleSize.width) / 2, y: 60, width: titleSize.width, height: titleSize.height)
                    titleString.draw(in: titleRect, withAttributes: titleAttributes)
                    
                    // 渲染内容
                    if slide.type != .title {
                        let contentFont = UIFont.systemFont(ofSize: CGFloat(styleModel.contentFontSize), weight: self.fontWeightFrom(styleModel.contentFontWeight))
                        let contentColor = UIColor(styleModel.contentColor)
                        let bulletColor = UIColor(styleModel.accentColor)
                        
                        let contentAttributes: [NSAttributedString.Key: Any] = [
                            .font: contentFont,
                            .foregroundColor: contentColor
                        ]
                        
                        var yOffset = 180.0 + titleSize.height
                        
                        for point in slide.content {
                            // 绘制项目符号
                            let bulletText = "•" // 简化版，实际应使用styleModel.bulletStyle
                            let bulletAttributes: [NSAttributedString.Key: Any] = [
                                .font: contentFont,
                                .foregroundColor: bulletColor
                            ]
                            let bulletString = bulletText as NSString
                            bulletString.draw(at: CGPoint(x: 100, y: yOffset), withAttributes: bulletAttributes)
                            
                            // 绘制项目内容
                            let pointString = point as NSString
                            let pointRect = CGRect(x: 140, y: yOffset, width: 1680, height: 1000)
                            let pointSize = pointString.boundingRect(with: CGSize(width: 1680, height: 1000),
                                                                  options: .usesLineFragmentOrigin,
                                                                  attributes: contentAttributes,
                                                                  context: nil)
                            pointString.draw(in: pointRect, withAttributes: contentAttributes)
                            
                            yOffset += pointSize.height + 30
                        }
                    }
                    
                    // 绘制页脚
                    if styleModel.showFooter {
                        let footerAttributes: [NSAttributedString.Key: Any] = [
                            .font: UIFont.systemFont(ofSize: 16),
                            .foregroundColor: UIColor(styleModel.footerColor)
                        ]
                        
                        // 页脚文本
                        if let footerText = styleModel.footerText {
                            let footerString = footerText as NSString
                            footerString.draw(at: CGPoint(x: 100, y: 1020), withAttributes: footerAttributes)
                        }
                        
                        // 页码
                        let pageString = "\(slide.index + 1)" as NSString
                        let pageSize = pageString.size(withAttributes: footerAttributes)
                        pageString.draw(at: CGPoint(x: 1820 - pageSize.width, y: 1020), withAttributes: footerAttributes)
                    }
                }
                
                continuation.resume(returning: image)
            }
        }
    }
    
    private func fontWeightFrom(_ weight: FontWeight) -> UIFont.Weight {
        switch weight {
        case .ultraLight: return .ultraLight
        case .thin: return .thin
        case .light: return .light
        case .regular: return .regular
        case .medium: return .medium
        case .semibold: return .semibold
        case .bold: return .bold
        case .heavy: return .heavy
        case .black: return .black
        }
    }
}

public enum ExportError: Error {
    case pdfPageCreationFailed
    case pdfWriteFailed
    case imageDataGenerationFailed
    case shareError
    case exportFailed
    case unsupportedExportFormat
}
```

这些代码示例提供了 OnlySlide 应用的核心功能实现，包括幻灯片生成、编辑和导出功能。您可以根据这些示例继续构建应用的其余部分，如用户管理、模板系统和更多高级功能。





